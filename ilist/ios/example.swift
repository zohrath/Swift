// This file was generated by json2swift. https://github.com/ijoshsmith/json2swift

import Foundation

//
// MARK: - Data Model
//
struct RootType: CreatableFromJSON { // TODO: Rename this struct
    let autoShareAllContents: Bool
    let autoShareNum: Int
    let autoShareType: Int
    let brand: Int
    let content: [Int]
    let created: String
    let disclaimer: Any?
    let iconUrl: URL
    let id: Int
    let identity: String
    let order: Int
    let pages: [Pages]
    let rewardType: Int
    let title: String
    let updated: String
    init(autoShareAllContents: Bool, autoShareNum: Int, autoShareType: Int, brand: Int, content: [Int], created: String, disclaimer: Any?, iconUrl: URL, id: Int, identity: String, order: Int, pages: [Pages], rewardType: Int, title: String, updated: String) {
        self.autoShareAllContents = autoShareAllContents
        self.autoShareNum = autoShareNum
        self.autoShareType = autoShareType
        self.brand = brand
        self.content = content
        self.created = created
        self.disclaimer = disclaimer
        self.iconUrl = iconUrl
        self.id = id
        self.identity = identity
        self.order = order
        self.pages = pages
        self.rewardType = rewardType
        self.title = title
        self.updated = updated
    }
    init?(json: [String: Any]) {
        guard let autoShareAllContents = json["auto_share_all_contents"] as? Bool else { return nil }
        guard let autoShareNum = json["auto_share_num"] as? Int else { return nil }
        guard let autoShareType = json["auto_share_type"] as? Int else { return nil }
        guard let brand = json["brand"] as? Int else { return nil }
        guard let content = json["content"] as? [Int] else { return nil }
        guard let created = json["created"] as? String else { return nil }
        guard let iconUrl = URL(json: json, key: "icon_url") else { return nil }
        guard let id = json["id"] as? Int else { return nil }
        guard let identity = json["identity"] as? String else { return nil }
        guard let order = json["order"] as? Int else { return nil }
        guard let pages = Pages.createRequiredInstances(from: json, arrayKey: "pages") else { return nil }
        guard let rewardType = json["reward_type"] as? Int else { return nil }
        guard let title = json["title"] as? String else { return nil }
        guard let updated = json["updated"] as? String else { return nil }
        let disclaimer = json["disclaimer"] as? Any
        self.init(autoShareAllContents: autoShareAllContents, autoShareNum: autoShareNum, autoShareType: autoShareType, brand: brand, content: content, created: created, disclaimer: disclaimer, iconUrl: iconUrl, id: id, identity: identity, order: order, pages: pages, rewardType: rewardType, title: title, updated: updated)
    }
    struct Pages: CreatableFromJSON { // TODO: Rename this struct
        let backgroundSoundUrl: Any?
        let backgrounds: [Backgrounds]
        let components: [Components]
        let consumeAction: Int
        let contents: [Any?]
        let created: String
        let frameUrl: Any?
        let id: Int
        let identity: String
        let isShareable: Bool
        let name: String
        let numberOfUses: Int
        let order: Int
        let reward: [Int]
        let updated: String
        init(backgroundSoundUrl: Any?, backgrounds: [Backgrounds], components: [Components], consumeAction: Int, contents: [Any?], created: String, frameUrl: Any?, id: Int, identity: String, isShareable: Bool, name: String, numberOfUses: Int, order: Int, reward: [Int], updated: String) {
            self.backgroundSoundUrl = backgroundSoundUrl
            self.backgrounds = backgrounds
            self.components = components
            self.consumeAction = consumeAction
            self.contents = contents
            self.created = created
            self.frameUrl = frameUrl
            self.id = id
            self.identity = identity
            self.isShareable = isShareable
            self.name = name
            self.numberOfUses = numberOfUses
            self.order = order
            self.reward = reward
            self.updated = updated
        }
        init?(json: [String: Any]) {
            guard let backgrounds = Backgrounds.createRequiredInstances(from: json, arrayKey: "backgrounds") else { return nil }
            guard let components = Components.createRequiredInstances(from: json, arrayKey: "components") else { return nil }
            guard let consumeAction = json["consume_action"] as? Int else { return nil }
            guard let contents = json["contents"] as? [Any?] else { return nil }
            guard let created = json["created"] as? String else { return nil }
            guard let id = json["id"] as? Int else { return nil }
            guard let identity = json["identity"] as? String else { return nil }
            guard let isShareable = json["is_shareable"] as? Bool else { return nil }
            guard let name = json["name"] as? String else { return nil }
            guard let numberOfUses = json["number_of_uses"] as? Int else { return nil }
            guard let order = json["order"] as? Int else { return nil }
            guard let reward = json["reward"] as? [Int] else { return nil }
            guard let updated = json["updated"] as? String else { return nil }
            let backgroundSoundUrl = json["background_sound_url"] as? Any
            let frameUrl = json["frame_url"] as? Any
            self.init(backgroundSoundUrl: backgroundSoundUrl, backgrounds: backgrounds, components: components, consumeAction: consumeAction, contents: contents, created: created, frameUrl: frameUrl, id: id, identity: identity, isShareable: isShareable, name: name, numberOfUses: numberOfUses, order: order, reward: reward, updated: updated)
        }
        struct Backgrounds: CreatableFromJSON { // TODO: Rename this struct
            let created: String
            let file: Any?
            let fileUrl: Any?
            let id: Int
            let meta: Meta
            let name: String
            let order: Int
            let pages: [Int]
            let type: String
            let updated: String
            init(created: String, file: Any?, fileUrl: Any?, id: Int, meta: Meta, name: String, order: Int, pages: [Int], type: String, updated: String) {
                self.created = created
                self.file = file
                self.fileUrl = fileUrl
                self.id = id
                self.meta = meta
                self.name = name
                self.order = order
                self.pages = pages
                self.type = type
                self.updated = updated
            }
            init?(json: [String: Any]) {
                guard let created = json["created"] as? String else { return nil }
                guard let id = json["id"] as? Int else { return nil }
                guard let meta = Meta(json: json, key: "meta") else { return nil }
                guard let name = json["name"] as? String else { return nil }
                guard let order = json["order"] as? Int else { return nil }
                guard let pages = json["pages"] as? [Int] else { return nil }
                guard let type = json["type"] as? String else { return nil }
                guard let updated = json["updated"] as? String else { return nil }
                let file = json["file"] as? Any
                let fileUrl = json["file_url"] as? Any
                self.init(created: created, file: file, fileUrl: fileUrl, id: id, meta: meta, name: name, order: order, pages: pages, type: type, updated: updated)
            }
            struct Meta: CreatableFromJSON { // TODO: Rename this struct
                init() {
                }
                init?(json: [String: Any]) {
                    self.init()
                }
            }
        }
        struct Components: CreatableFromJSON { // TODO: Rename this struct
            let contentPage: Int
            let created: String
            let file: Any?
            let id: Int
            let marginBottom: Int
            let marginEdgePercentage: Double
            let marginHorizontal: Int
            let meta: Meta
            let order: Int
            let shareable: Bool
            let thumbnail: Any?
            let type: String
            let updated: String
            init(contentPage: Int, created: String, file: Any?, id: Int, marginBottom: Int, marginEdgePercentage: Double, marginHorizontal: Int, meta: Meta, order: Int, shareable: Bool, thumbnail: Any?, type: String, updated: String) {
                self.contentPage = contentPage
                self.created = created
                self.file = file
                self.id = id
                self.marginBottom = marginBottom
                self.marginEdgePercentage = marginEdgePercentage
                self.marginHorizontal = marginHorizontal
                self.meta = meta
                self.order = order
                self.shareable = shareable
                self.thumbnail = thumbnail
                self.type = type
                self.updated = updated
            }
            init?(json: [String: Any]) {
                guard let contentPage = json["content_page"] as? Int else { return nil }
                guard let created = json["created"] as? String else { return nil }
                guard let id = json["id"] as? Int else { return nil }
                guard let marginBottom = json["margin_bottom"] as? Int else { return nil }
                guard let marginEdgePercentage = Double(json: json, key: "margin_edge_percentage") else { return nil }
                guard let marginHorizontal = json["margin_horizontal"] as? Int else { return nil }
                guard let meta = Meta(json: json, key: "meta") else { return nil }
                guard let order = json["order"] as? Int else { return nil }
                guard let shareable = json["shareable"] as? Bool else { return nil }
                guard let type = json["type"] as? String else { return nil }
                guard let updated = json["updated"] as? String else { return nil }
                let file = json["file"] as? Any
                let thumbnail = json["thumbnail"] as? Any
                self.init(contentPage: contentPage, created: created, file: file, id: id, marginBottom: marginBottom, marginEdgePercentage: marginEdgePercentage, marginHorizontal: marginHorizontal, meta: meta, order: order, shareable: shareable, thumbnail: thumbnail, type: type, updated: updated)
            }
            struct Meta: CreatableFromJSON { // TODO: Rename this struct
                let color: String
                let fontSize: String
                let fontWeight: String?
                let text: String?
                init(color: String, fontSize: String, fontWeight: String?, text: String?) {
                    self.color = color
                    self.fontSize = fontSize
                    self.fontWeight = fontWeight
                    self.text = text
                }
                init?(json: [String: Any]) {
                    guard let color = json["color"] as? String else { return nil }
                    guard let fontSize = json["font_size"] as? String else { return nil }
                    let fontWeight = json["font_weight"] as? String
                    let text = json["text"] as? String
                    self.init(color: color, fontSize: fontSize, fontWeight: fontWeight, text: text)
                }
            }
        }
    }
}

//
// MARK: - JSON Utilities
//
/// Adopted by a type that can be instantiated from JSON data.
protocol CreatableFromJSON {
    /// Attempts to configure a new instance of the conforming type with values from a JSON dictionary.
    init?(json: [String: Any])
}

extension CreatableFromJSON {
    /// Attempts to configure a new instance using a JSON dictionary selected by the `key` argument.
    init?(json: [String: Any], key: String) {
        guard let jsonDictionary = json[key] as? [String: Any] else { return nil }
        self.init(json: jsonDictionary)
    }

    /// Attempts to produce an array of instances of the conforming type based on an array in the JSON dictionary.
    /// - Returns: `nil` if the JSON array is missing or if there is an invalid/null element in the JSON array.
    static func createRequiredInstances(from json: [String: Any], arrayKey: String) -> [Self]? {
        guard let jsonDictionaries = json[arrayKey] as? [[String: Any]] else { return nil }
        return createRequiredInstances(from: jsonDictionaries)
    }

    /// Attempts to produce an array of instances of the conforming type based on an array of JSON dictionaries.
    /// - Returns: `nil` if there is an invalid/null element in the JSON array.
    static func createRequiredInstances(from jsonDictionaries: [[String: Any]]) -> [Self]? {
        var array = [Self]()
        for jsonDictionary in jsonDictionaries {
            guard let instance = Self.init(json: jsonDictionary) else { return nil }
            array.append(instance)
        }
        return array
    }

    /// Attempts to produce an array of instances of the conforming type, or `nil`, based on an array in the JSON dictionary.
    /// - Returns: `nil` if the JSON array is missing, or an array with `nil` for each invalid/null element in the JSON array.
    static func createOptionalInstances(from json: [String: Any], arrayKey: String) -> [Self?]? {
        guard let array = json[arrayKey] as? [Any] else { return nil }
        return createOptionalInstances(from: array)
    }

    /// Attempts to produce an array of instances of the conforming type, or `nil`, based on an array.
    /// - Returns: An array of instances of the conforming type and `nil` for each invalid/null element in the source array.
    static func createOptionalInstances(from array: [Any]) -> [Self?] {
        return array.map { item in
            if let jsonDictionary = item as? [String: Any] {
                return Self.init(json: jsonDictionary)
            }
            else {
                return nil
            }
        }
    }
}

extension Date {
    // Date formatters are cached because they are expensive to create. All cache access is performed on a serial queue.
    private static let cacheQueue = DispatchQueue(label: "DateFormatterCacheQueue")
    private static var formatterCache = [String: DateFormatter]()
    private static func dateFormatter(with format: String) -> DateFormatter {
        if let formatter = formatterCache[format] { return formatter }
        let formatter = DateFormatter()
        formatter.dateFormat = format
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.calendar = Calendar(identifier: .gregorian)
        formatter.timeZone = TimeZone(secondsFromGMT: 0)! // UTC is assumed, but won't interfere with a format-specified time zone.
        formatterCache[format] = formatter
        return formatter
    }

    static func parse(string: String, format: String) -> Date? {
        var formatter: DateFormatter!
        cacheQueue.sync { formatter = dateFormatter(with: format) }
        return formatter.date(from: string)
    }

    init?(json: [String: Any], key: String, format: String) {
        guard let string = json[key] as? String else { return nil }
        guard let date = Date.parse(string: string, format: format) else { return nil }
        self.init(timeIntervalSinceReferenceDate: date.timeIntervalSinceReferenceDate)
    }
}

extension URL {
    init?(json: [String: Any], key: String) {
        guard let string = json[key] as? String else { return nil }
        self.init(string: string)
    }
}

extension Double {
    init?(json: [String: Any], key: String) {
        // Explicitly unboxing the number allows an integer to be converted to a double,
        // which is needed when a JSON attribute value can have either representation.
        guard let nsNumber = json[key] as? NSNumber else { return nil }
        self.init(_: nsNumber.doubleValue)
    }
}

extension Array where Element: NSNumber {
    // Convert integers to doubles, for example [1, 2.0] becomes [1.0, 2.0]
    // This is necessary because ([1, 2.0] as? [Double]) yields nil.
    func toDoubleArray() -> [Double] {
        return map { $0.doubleValue }
    }
}

extension Array where Element: CustomStringConvertible {
    func toDateArray(withFormat format: String) -> [Date]? {
        var dateArray = [Date]()
        for string in self {
            guard let date = Date.parse(string: String(describing: string), format: format) else { return nil }
            dateArray.append(date)
        }
        return dateArray
    }

    func toURLArray() -> [URL]? {
        var urlArray = [URL]()
        for string in self {
           guard let url = URL(string: String(describing: string)) else { return nil }
           urlArray.append(url)
        }
        return urlArray
    }
}

extension Array where Element: Any {
    func toOptionalValueArray<Value>() -> [Value?] {
        return map { ($0 is NSNull) ? nil : ($0 as? Value) }
    }

    func toOptionalDateArray(withFormat format: String) -> [Date?] {
        return map { item in
            guard let string = item as? String else { return nil }
            return Date.parse(string: string, format: format)
        }
    }

    func toOptionalDoubleArray() -> [Double?] {
        return map { item in
            guard let nsNumber = item as? NSNumber else { return nil }
            return nsNumber.doubleValue
        }
    }

    func toOptionalURLArray() -> [URL?] {
        return map { item in
            guard let string = item as? String else { return nil }
            return URL(string: string)
        }
    }
}
